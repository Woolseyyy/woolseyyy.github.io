{"meta":{"title":"Woolsey's Blog","subtitle":null,"description":null,"author":"woolsey","url":"https://woolseyyy.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2019-10-12T01:53:21.451Z","updated":"2019-10-12T01:53:21.451Z","comments":false,"path":"/404.html","permalink":"https://woolseyyy.github.io//404.html","excerpt":"","text":""},{"title":"关于","date":"2019-10-12T01:53:21.457Z","updated":"2019-10-12T01:53:21.457Z","comments":false,"path":"about/index.html","permalink":"https://woolseyyy.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2019-10-12T01:53:21.458Z","updated":"2019-10-12T01:53:21.458Z","comments":false,"path":"books/index.html","permalink":"https://woolseyyy.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-10-12T01:53:21.460Z","updated":"2019-10-12T01:53:21.460Z","comments":false,"path":"categories/index.html","permalink":"https://woolseyyy.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-10-12T01:53:21.461Z","updated":"2019-10-12T01:53:21.461Z","comments":true,"path":"links/index.html","permalink":"https://woolseyyy.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-10-12T01:53:21.462Z","updated":"2019-10-12T01:53:21.462Z","comments":false,"path":"repository/index.html","permalink":"https://woolseyyy.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-10-12T01:53:21.464Z","updated":"2019-10-12T01:53:21.464Z","comments":false,"path":"tags/index.html","permalink":"https://woolseyyy.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Splay Trees 学习笔记","slug":"splay_tree","date":"2016-05-27T01:28:10.000Z","updated":"2019-10-12T05:28:47.900Z","comments":true,"path":"2016/05/27/splay_tree/","link":"","permalink":"https://woolseyyy.github.io/2016/05/27/splay_tree/","excerpt":"","text":"Splays Trees 也是一种二叉搜索树，用于提高连续搜索的效率。Splay Trees 通过将被访问到的节点放于根，提升访问速度。 它与AVL Trees 的效果有所区别。AVL树通过使树balanced降低树的高度至logN，从而使得单次搜索的复杂度为O(logN)。而Splay Trees则通过每次将被访问到的节点置于根，使得m次连续搜索的复杂度为O(mlogN)。 下面我们将介绍Splay Trees的实现及PTA中的相关题目。m次连续搜索复杂度为O(mlogN)我们在摊还分析博文中进行证明。 实现 根据不同的情况，Splay Trees采取不同的调整方法，直到被访问的节点置于根节点。 我们记被访问的节点为X，其父节点为P，其祖父节点为G。 首先我们将情况分为P是根节点和不是根节点。 P是根节点 交换P与X。结束调整。 P不是根节点 在该情况下，分为zig-zig情况和zig-zag情况。根据不同情况采取不同的旋转方法，旋转结束后，继续调整，直到被访问的节点处于根节点。 Zig-Zig X, P, G处于同一方向时，只需旋转一次，将X, P, G颠倒即可。 Zig-Zag X, P, G处于不同方向时，需要旋转两次，先旋转P, X，再旋转X, G 删除 在删除一个节点时，按如下步骤操作： 找到并删除该节点 访问该节点子树中最大的节点（此时该最大节点会处于该子树的根，且没有right child） 使删除节点的右子树成为 左子树最大节点 的right child 题目 For the result of accessing the keys 3, 9, 1, 5 in order in the splay tree in the following figure, which one of the following statements is FALSE? (1分) A. 5 is the root B. 1 and 9 are siblings C. 6 and 10 are siblings D. 3 is the parent of 4 答案是D","categories":[{"name":"-基础算法","slug":"基础算法","permalink":"https://woolseyyy.github.io/categories/基础算法/"}],"tags":[{"name":"-数据结构","slug":"数据结构","permalink":"https://woolseyyy.github.io/tags/数据结构/"}]},{"title":"AVL Trees 学习笔记","slug":"avl_tree","date":"2016-05-26T04:19:05.000Z","updated":"2019-10-12T04:51:42.195Z","comments":true,"path":"2016/05/26/avl_tree/","link":"","permalink":"https://woolseyyy.github.io/2016/05/26/avl_tree/","excerpt":"","text":"AVL Trees 是一种特殊的二叉搜索树，它的作用是通过自我调整，让整棵树保持平衡，从而降低整棵树的高度，以提高查找效率。 本文将首先介绍AVL Trees，然后介绍它的实现方法，性能评估，最后分析题目。 Introduction 特点 通过自我调整使树趋于平衡，降低树的高度，提高搜索效率 本质 二叉搜索树 变化 相比于二叉搜索树，有两个变化，一是每个节点增加了BF属性用于存储左子树和右子树的高度差，二是每次增加或删除节点后都会进行调整，使之balance 实现 结构 增加了BF属性的二叉搜索树 1234567typedef struct node* tree;struct node&#123; element key; tree left; tree right; int BF;&#125; BF = height of left tree - height of right tree 通过判断每个节点的BF值判断树是否height balanced. 若失去平衡，则开始调整。 Height Balanced An empty binary tree is height balanced. If T is a nonempty binary tree with TL and TR as its left and right subtrees, then T is height balanced iff (1) TL and TR are height balanced, and (2) | hL - hR | &lt; 1 where hL and hR are the heights of TL and TR , respectively. 调整触发条件 更新BF值 从增加或删除节点的位置开始向上遍历，访问BF值 若有BF&lt; -1 || BF &gt; 1 调整该节点及其子树 若一直到根节点BF都正常则无需调整 调整完成，更新BF值 调整 共有 RR, LL, RL, LR 四种情况 RR 需要注意的是，矩形（如BL，BR， AL）表示的不是一个节点，而是表示一棵子树，A表示的不一定是root，而是一个Trouble Maker节点。 LL LL情况与RR相似，它们是对称的。它们的共同点是，都是在**从 *Trouble Maker节点 *到 *其子节点 * 到 子节点的子树 **这条路径上，旋转一次。 LR LR和RL的情况就要稍微复杂，需要进行两次旋转。 这次旋转中事实上包括了两次旋转，首先是B, C, C的子树路径上进行一次左旋转： 然后是A, C, B路径上的第二次旋转: RL RL的情况与LR情况相似 性能评估 每次操作需要遍历从最底端到root的各个节点，时间复杂度为O(h)，调整操作时间复杂度为O(1)。故每次操作时间复杂度为O(h)。 又 h = O(lnN) 故操作时间复杂度为O(lnN) 证明 h = O(lnN) 记一个高度为h的树，节点数为nh 一棵高度为h，节点数最少的树是这样的形式： 由此我们可以得出nh = nh-1 + nh-2 + 1 令Fi = nh + 1 有Fi = Fi-1 + Fi-2 我们可以发现 Fi 符合斐波那契数列，且通过将h=1, h=2, h=3 代入，我们可以得出i = h+2 即 nh+2 - 1 符合斐波那契数列 根据斐波那契数列的理论 $ F_i = \\frac{1}{\\sqrt 5} (\\frac{1+{\\sqrt 5}}{2})^i $ 我们可以得到 $ n_h = \\frac{1}{\\sqrt 5} (\\frac{1+{\\sqrt 5}}{2})^{h+2} - 1 $ 故 h=O(lnN) 分析题目 Insert 2, 1, 4, 5, 9, 3, 6, 7 into an initially empty AVL tree. Which one of the following statements is FALSE? (1分) A. 4 is the root B. 2 and 6 are siblings C. 3 and 7 are siblings D. 9 is the parent of 7 让我们来模拟插入的过程 故答案为C If the depth of an AVL tree is 6 (the depth of an empty tree is defined to be -1), then the minimum possible number of nodes in this tree is: (1分) A. 13 B. 17 C. 20 D. 33 在证明h=O(lnN)的过程部分我们有 n最少时，nh = nh-1 + nh-2 + 1 又 depth = height - 1 故ndepth=6 = n7 = 33 答案为 D","categories":[{"name":"-基础算法","slug":"基础算法","permalink":"https://woolseyyy.github.io/categories/基础算法/"}],"tags":[{"name":"-数据结构","slug":"数据结构","permalink":"https://woolseyyy.github.io/tags/数据结构/"}]}]}
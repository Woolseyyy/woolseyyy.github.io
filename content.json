{"meta":{"title":"Woolsey's Blog","subtitle":null,"description":null,"author":"woolsey","url":"https://woolseyyy.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2019-10-12T01:53:21.451Z","updated":"2019-10-12T01:53:21.451Z","comments":false,"path":"/404.html","permalink":"https://woolseyyy.github.io//404.html","excerpt":"","text":""},{"title":"关于","date":"2019-10-12T01:53:21.457Z","updated":"2019-10-12T01:53:21.457Z","comments":false,"path":"about/index.html","permalink":"https://woolseyyy.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2019-10-12T01:53:21.458Z","updated":"2019-10-12T01:53:21.458Z","comments":false,"path":"books/index.html","permalink":"https://woolseyyy.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-10-12T01:53:21.460Z","updated":"2019-10-12T01:53:21.460Z","comments":false,"path":"categories/index.html","permalink":"https://woolseyyy.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-10-12T01:53:21.461Z","updated":"2019-10-12T01:53:21.461Z","comments":true,"path":"links/index.html","permalink":"https://woolseyyy.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-10-12T01:53:21.462Z","updated":"2019-10-12T01:53:21.462Z","comments":false,"path":"repository/index.html","permalink":"https://woolseyyy.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-10-12T01:53:21.464Z","updated":"2019-10-12T01:53:21.464Z","comments":false,"path":"tags/index.html","permalink":"https://woolseyyy.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Red-Black Trees 红黑树","slug":"Red-Black_Trees","date":"2016-05-29T01:40:22.000Z","updated":"2019-10-12T05:31:41.816Z","comments":true,"path":"2016/05/29/Red-Black_Trees/","link":"","permalink":"https://woolseyyy.github.io/2016/05/29/Red-Black_Trees/","excerpt":"","text":"红黑树是另一种自平衡二叉查找树。它通过较为复杂的调整，实现一种“局部平衡”。它的性能较为高效，应用广泛，被应用于linux内核进程调度，实现关联数组等。 本文将首先介绍红黑树的特点及其与AVL树的比较，然后说明红黑树的实现方式，评价红黑树的性能，最后对红黑树进行实践。 #红黑树的特点 本节将整体介绍红黑树的特点，目的是探究红黑树的特点和优异之处。完全不了解红黑树的读者可以先跳过本节，在阅读完红黑树的实现之后再来阅读本节。 红黑树是一种自平衡的二叉查找树。它的实现机制非常复杂，所以一直困扰我的一个疑问是：为什么在逻辑简单的AVL树之后人们还要发明这样一种实现复杂的树，并且红黑树的应用比AVL树更为广泛？ AVL树是最早的一种自平衡二叉搜索树。如果说伸展树是为了节省AVL树节点中的height属性，那么红黑树，一棵这么复杂的树，的存在又是为了什么呢？ 平衡二叉树的追求的是全局均衡，如在做插入，删除操作时，需要调整整棵树，显然这是费时的，因此希望在做调整时，是局部调整，因此提出了红黑树，这样一种高效的数据结构(也是最变态的一种数据结构)。 区别于严格平衡的AVL树，红黑树的自平衡是一种“局部平衡”——它只要求部分地达到平衡要求，降低了对旋转的要求，从而提高了性能。红黑树对以往的数据不会过多的调整，且可以保证任何不平衡在三次以内的旋转得到解决，红黑树的算法时间复杂度和AVL相同，但统计性能比AVL树更高。 红黑树在删除时节点旋转次数是O(1)，平衡因子调整次数是O(logn)，而AVL树则两者都是O(logn)。红黑树和AVL树在插入时，节点旋转次数都是O(1)，平衡因子调整次数都是O(logn)。 AVL树的删除 引自维基百科： Let node X be the node which we have to delete, and let node Y be a node in the tree we need to find to take node X’s place, and let node Z be the actual node we take out of the tree. Steps to consider when deleting a node in an AVL tree are the following: If node X is a leaf or has only one child, skip to step 5 with Z:=X. Otherwise, determine node Y by finding the smallest[8] node in node X’s right subtree (the in-order successor of X − it does not have a left child) or the largest in its left subtree (the in-order predecessor of X − it does not have a right child). Exchange all the child and parent links of node X with those of node Y. In this step, the in-order sequence between nodes X and Y is temporarily disturbed, but the tree structure doesn’t change. Choose node Z to be all the child and parent links of old node Y = those of new node X. If node Z has a subtree (which then is a leaf), attach it to Z’s parent. If node Z was the root (its parent is null), update root. Delete node Z. Retrace the path back up the tree (starting with node Z’s parent) to the root, adjusting the balance factors as needed. Since with a single deletion the height of an AVL subtree cannot decrease by more than one, the temporary balance factor of a node will be in the range from −2 to +2. If the balance factor becomes ±2 then the subtree is unbalanced and needs to be rotated. The various cases of rotations are described in section Rebalancing. 仔细研究rebalancing，我们可以发现，insertion下，旋转后与插入后子树的高度相同，而deletion下，旋转后树的高度会变化。所以删除的旋转可能会进行O(logN)次。 （在AVL Trees 学习笔记一文中，主要是根据上课的课件所做的整理，所以并没有考虑删除的情况。笔者目前暂时不对AVL树的插入、删除、旋转及其实现做详细的说明，若有需求可以参考维基百科中对AVL树的说明） 因此，在动态数据的方面，红黑树的表现要优于AVL树。这也是为什么红黑树被应用于linux内核进程调度、关联数组。 实现 定义 A red-black tree is a binary search tree that satisfies the following red-black properties: Every node is either red or black. The root is black. Every leaf (NIL) is black. If a node is red, then both its children are black. For each node, all simple paths from the node to descendant leaves contain the same number of black nodes. 插入 若在 黑节点 下插入，只需让插入节点为红色即可。 若在红节点下插入，而红节点没有sibling node，如在下图插入的“9”节点： 只需将7，8，9进行旋转，将其中的父节点置于黑色即可。 若红节点的sibling node是黑节点，我们可以证明这样的情况不存在因为这样这两个节点的父节点将违反第五条原则(For each node, all simple paths from the node to descendant leaves contain the same number of black nodes): 最后只剩下在红节点下插入节点，且红节点的兄弟节点为红节点，且它的父节点一定为黑色节点，也就是这样的情况： 在这样的情况下，我们只需要将颜色变化即可。 此时，若树遵循红黑树定义，则停止调整，但也有可能调整后会出现这样的情况： 若是case1， 则我们将其通过旋转转换为case2，再继续进行调整。 首先变换颜色，然后再进行一次旋转，调整结束。 因为此时父节点为黑色，所以此时的树一定满足红黑树定义，不需要再进行调整。 通过上面的过程我们可以看到，红黑树的插入最多进行三次旋转。 对称的情况不予赘述。 插入的例子 插入前： 插入4： 变换颜色，但上一层不满足红黑树定义了： 旋转，变换为case2： 变色并旋转： 结束 待续","categories":[{"name":"-基础算法","slug":"基础算法","permalink":"https://woolseyyy.github.io/categories/基础算法/"}],"tags":[{"name":"-数据结构","slug":"数据结构","permalink":"https://woolseyyy.github.io/tags/数据结构/"}]},{"title":"Amortized Analysis","slug":"Amortized_Analysis","date":"2016-05-27T01:28:10.000Z","updated":"2019-10-12T05:30:02.236Z","comments":true,"path":"2016/05/27/Amortized_Analysis/","link":"","permalink":"https://woolseyyy.github.io/2016/05/27/Amortized_Analysis/","excerpt":"","text":"摊还分析考察一个操作序列中所执行的所有操作的平均时间，来评价操作的代价。这个操作序列中也许某一操作的代价很高，但因为还有其他操作，所以这些操作的平均代价并没有那么高。 本文将首先将这种代价分析方式与最坏情况时间复杂度和平均时间复杂度两种方式进行区分，然后通过一篇其他人的博文说明摊还分析的三种方法，并对三种方法进行简要总结，最后对摊还分析方法进行实践。 对比 摊还分析是相对于最坏情况时间复杂度分析、平均时间复杂度分析的另一种时间复杂度分析。它的bound介于两者之间。 这样的评价方式相比于最坏情况复杂度要更接近于实际情况，因为这个“代价较高的操作”往往不会经常发生，比如栈操作中的Multi-pop(k)，虽然它会花费k个时间，但在它之前需要有k个push这个操作才能进行，也就是说无法一直进行这个操作。 而相比较于平均时间复杂度分析，摊还分析不考虑概率问题，它考虑的是最坏情况下每个操作的平均代价。 摊还分析方法 转载自：codeplayer`s blog 先来直观的介绍一下什么是摊还分析：在摊还分析中，我们求数据结构的一个操作序列中所执行的所有操作的平均时间，来评价操作的代价。这样，我们就可以说明一个操作的平均代价是很低的，即使序列中某个单一操作的代价很高。摊还分析不同于平均情况分析，它不涉及概率，它可以保证最坏情况下每个操作的平均性能。 在学习摊还分析的时候要注意，在摊还分析中赋予对象的费用仅仅是用来分析而已，不需要也不应该出现在程序中。通过做瘫痪分析，通常可以获得对某种特定数据结构的认识，这种认识有助于优化设计。 聚合分析 使用聚合分析，我们可以证明对所有n，一个n个操作的序列最坏情况下花费的总时间为T(n)。因此，在最坏情况下，每个操作的平均时间，或摊还代价为T(n)/n。注意，此摊还代价是适用于每个操作的，即使序列中有多种类型操作。下面通过两个例子来了解一下聚合分析。 栈操作 经典的栈操作，这里不过多叙述，它支持三种操作： PUSH(S, x)，压入对象x。 POP(S)，弹出一个对象。 MULTIPOP(S,k)，弹出k个对象，如果栈中对象的数量少于k，则将所有对象弹出。 我们来分析一下n个这三种操作在一个空栈上的运行时间。一个MULTIPOP操作的最坏情况时间为О(n)，因为栈的大小为最大为n，PUSH和POP最坏情况时间均为1，假设序列中的有О(n)个MULTIPOP操作，所以我们通过分析每个操作的最坏情况时间得到操作序列的最坏情况时间为О(n^2)，但是这不是一个确界。 通过使用聚合分析，考虑整个序列的n个操作，可以得到更好的上界。实际上虽然MULTIPOP操作的最坏情况时间很高，但是在一个空栈上执行PUSH、POP、MULTIPOP的操作序列，代价最多是О(n)。因为我们将一个对象压入到栈后，最多只将其弹出一次，所以一个非空的栈，可以执行的POP次数最多为n。因此上述操作序列最多花费О(n)时间，而一个操作的平均时间为О(n) / n = О(1)。在聚合分析中，我们将每个操作的摊还代价设定为平均代价。所以，这三种操作的摊还代价均为О(1)。 这里我们并未使用概率分析就证明了一个栈操作的平均代价。我们实际上得出的是一个n个操作序列的最坏情况运行时间О(n)，再除以n得到了每个操作的平均代价，或者说摊还代价。 二进制计数器递增 一个k位二进制计数器递增的问题的例子。简单来说就是使用二进制来计数，并将这个二进制数放到一个数组中，可以使用一个INCREMENT的操作来对这个二进制数增加1。A.length = k，将最低位保存在A[0]中，最高位保存在A[k-1]中。INCREMENT的伪代码如下： INCREMENT 123456i = 0while i &lt; A.length and A[i] == 1 A[i] = 0 i = i+1if i &lt; A.length A[i] = 1 在2～4行while循环时，我们希望将1加在第i位上。如果A[i]=1，那么加1操作会将第i位翻转为0，并产生一个进位——在一次循环中将1加到i+1位上。否则循环结束，此时若i 与上一个例子类似，粗略的分析会的到一个正确但是不紧的界。最坏情况下翻转数组上所有的位，INCREMENT执行一次花费Θ(k)时间，因此n个INCREMENT的最坏时间为О(nk)。但是通过摊还分析，我们可以得到最坏运行时间О(n)，因为不可能每次INCREMENT都翻转所有的位。实际上，对一个初值为0的计数器，执行n个INCREMENT的过车给你中，A[i]会翻转n/(2^i)次。所以我们可以得到的执行翻转操作的总数为：2n(1−12k−1)&lt;2n2n(1-\\frac{1}{2^{k-1}}) &lt; 2n2n(1−2k−11​)&lt;2n 所以可以得到n个INCREMENT操作序列的最坏情况时间为О(n)，摊还代价为О(n)/n = О(1)。 核算法 用核算法进行摊还分析时，我们对不同操作赋予不同费用，赋予某些操作的费用可能多于或少于实际代价。我们将赋予一个操作的费用成为它的摊还代价。当一个操作的摊还代价超出其实际代价时，我们将差额存入数据结构中的特定对象，存入的差额成为信用。对于后续操作中摊还代价小于实际代价的情况，信用可以用来支付差额。 我们必须小心地选择操作的摊还代价。如果我们希望通过分析摊还代价来证明每个操作的平均代价的最坏情况很小，就应确保操作序列的总摊还代价给出了序列总真实代价的上界。而且，这种关系必须对所有操作序列都成立。数据结构中存储的信用恰好等于总摊还代价与总实际代价的差值。数据结构所关联的信用必须一直非负值，如果在某个步骤，我们允许信用为负值，那么当时的总摊还代价就会低于总实际代价，对于到那个时刻为止的操作序列，总摊还代价就不再是总实际代价的上界了。 栈操作 为了说明摊还分析的核算法，再次使用栈的例子。我们赋予PUSH、POP、MULTIPOP如下的摊还代价： PUSH 2 POP 0 MULTIPOP 0 PUSH时我们将1元的代价支付PUSH操作的实际代价，将剩余的1元存为信用，这1元实际上是作为将来被POP时代价的预付费。当执行一个POP时，并不缴纳任何费用，而是使用存储的信用来支付其实际代价，对于MULTIPOP也是一样的。因为栈中元素的数量总是非负的，所以可以保证信用也非负的。因此，对任意n个PUSH、POP、MULTIPOP组成的序列，总摊还代价О(n)为总实际代价的上界。 二进制计数器递增 在这个例子中，对一次置位操作，我们设其摊还代价为2元，用1元支付实际代价，1元存为信用，用来支付将来复位操作的代价。在任何时刻，计数器中任何为1的位都存有1元信用，这样在复位的时候，我们就不需要支付任何费用了。 INCREMENT过程一次最多置位一次，因此摊还代价最多为2美元，计数器中1的个数永远不会为负，所以对于n个INCREMENT操作的总摊还代价О(n)是总实际代价的上界。 势能法 势能法摊还分析并不预付代价表示为数据结构中特定对象的信用，而是表示为“势能”，将势能释放即可用来支付未来操作的代价。我们将势能于整个数据结构而不是特定对象相关联。 工作方式如下。对一个初始数据结构D0执行n个操作，对每个i=1,2,…,n，令ci为第i个操作的实际代价，令Di为数据结构Di-1执行第i个操作得到的结果数据结构。势函数Φ将每个数据结构Di映射到一个实数Φ(Di)，此值即为关联到数据结构Di的_势_。第i个操作的摊还代价ci用势函数Φ定义为：**ci = ci + Φ(Di) - Φ（Di-1）** 所以每个操作的摊还代价等于其实际代价加上此操作引起的势能变化。则n个操作的总摊还代价为 : Ci(总摊还)= Ci(总实际)+ f(Di)-f(D0) 不同的势函数会产生不同的摊还代价，但摊还代价仍未实际代价的上界。在选择势函数时，我们常常发现可以做出一定的权衡，是否使用最佳势函数依赖于对时间界的要求。 两个例子还是盏和二进制计数器，不过势能法分析起来使用公式计算较多，在这里公式写起来不太方便就不详细叙述了。总体思想就是将预支付的代价添加的整个数据结构的势能中，将势能释放即可支付未来操作的代价。 三种方法的简要总结 聚合分析是简单地通过理解来得出一系列操作所需要的总代价，并由此得出每个操作的平均代价。 核算法则是通过“精妙地设计每个操作的摊还代价”，来获得整体的摊还代价。势能法则与核算法相似，只不过是从整体考虑势。 从经验要求度来说，聚合分析高于核算法高于势能法。所以在我看来，虽然理解上聚合分析最简单，其次是核算法，势能法最复杂，但从操作上说，顺序是反过来的。不妨以这样的思路去对待这三种方法： 首先掌握的是势能法（找到“势能”所对应的对象，再通过它来获得每个操作的摊还代价，最后得出n个操作的代价），在熟练之后，我们可以直接根据经验得到每个操作的摊还代价，也就掌握了核算法，最后进一步熟练，我们就可以直接理解得到n个操作的代价了，也就是掌握了聚合分析。 实践 证明 Splay Trees连续的M次操作，最多花费O(MlogN)的时间 我们利用势能法来证明。 记 S(i) 为 i 节点的后裔的个数（包括自身），R(i) 为 i 节点的秩，即为logS(i)。令势能函数为 ϕ(T)=∑i∈TR(i)\\phi (T) = \\sum_{i\\in T} {R(i)} ϕ(T)=i∈T∑​R(i) 记Ri(X)R_i(X)Ri​(X)为旋转前X的秩，Rf(X)R_f(X)Rf​(X)为旋转后X的秩。 下面我们分别分析Zig, Zig-Zag, Zig-Zig三种情况下的旋转的摊还成本。一次访问调整的摊还成本是旋转摊还成本的和。 Zig 单次旋转下实际成本为 1，势能变化Rf(X)+Rf(P)−Ri(X)−Ri(P)R_f(X) + R_f(P) - R_i(X) - R_i(P)Rf​(X)+Rf​(P)−Ri​(X)−Ri​(P)（因为A, B, C, D四棵子树节点数均未变化，所以其中的秩都未变化，势能变化，即秩变化，就是X和P的秩的变化） 故Zig情况的摊还成本为1+Rf(X)+Rf(P)−Ri(X)−Ri(P)1 + R_f(X) + R_f(P) - R_i(X) - R_i(P)1+Rf​(X)+Rf​(P)−Ri​(X)−Ri​(P) 又$ R_f§ &lt; R_f(X) , R_i§ &gt; R_i(X)$ 摊还成本 $ &lt; 1 + 2(R_f(X) - R_i(X)) $ 又 $ R_f(X) &gt; R_i(X) $ 故摊还成本 $ &lt; 1 + 3(R_f(X) - R_i(X)) $ Zig-Zag 之字形旋转实际成本为2， 势能变化Rf(X)+Rf(P)+Rf(G)−Ri(X)−Ri(P)−Ri(G)R_f(X) + R_f(P) + R_f(G) - R_i(X) - R_i(P) - R_i(G)Rf​(X)+Rf​(P)+Rf​(G)−Ri​(X)−Ri​(P)−Ri​(G) 故摊还成本为2+Rf(X)+Rf(P)+Rf(G)−Ri(X)−Ri(P)−Ri(G)2 + R_f(X) + R_f(P) + R_f(G) - R_i(X) - R_i(P) - R_i(G)2+Rf​(X)+Rf​(P)+Rf​(G)−Ri​(X)−Ri​(P)−Ri​(G) 而$ R_i(G) = R_f(X)$ 故摊还成本为2+Rf(P)+Rf(G)−Ri(X)−Ri(P)2 + R_f(P) + R_f(G) - R_i(X) - R_i(P)2+Rf​(P)+Rf​(G)−Ri​(X)−Ri​(P) 又 $ S_f§ + S_f(G) &lt; S_f(X) \\Rightarrow R_f§ + R_f(G) &lt; 2R_f(X) - 2$ if a+b&lt; c and a, b are integer loga+logb≤2logc−2loga + logb \\le 2logc - 2 loga+logb≤2logc−2 证明略 故摊还成本 &lt; 2Rf(X)−Ri(X)−Ri(P)2R_f(X) - R_i(X) - R_i(P)2Rf​(X)−Ri​(X)−Ri​(P) 又 $ R_i§ &gt; R_i(X) $ 故摊还成本 &lt; 2Rf(X)−2Ri(X)2R_f(X) - 2R_i(X)2Rf​(X)−2Ri​(X) 又 $ R_f(X) &gt; R_i(X) $ 故摊还成本 $ &lt; 3(R_f(X) - R_i(X)) $ Zig-Zig 一字形旋转实际成本为2， 势能变化Rf(X)+Rf(P)+Rf(G)−Ri(X)−Ri(P)−Ri(G)R_f(X) + R_f(P) + R_f(G) - R_i(X) - R_i(P) - R_i(G)Rf​(X)+Rf​(P)+Rf​(G)−Ri​(X)−Ri​(P)−Ri​(G) 故摊还成本为2+Rf(X)+Rf(P)+Rf(G)−Ri(X)−Ri(P)−Ri(G)2 + R_f(X) + R_f(P) + R_f(G) - R_i(X) - R_i(P) - R_i(G)2+Rf​(X)+Rf​(P)+Rf​(G)−Ri​(X)−Ri​(P)−Ri​(G) 而$ R_i(G) = R_f(X)$ 故摊还成本为2+Rf(P)+Rf(G)−Ri(X)−Ri(P)2 + R_f(P) + R_f(G) - R_i(X) - R_i(P)2+Rf​(P)+Rf​(G)−Ri​(X)−Ri​(P) 又 $ S_i(X) + S_f(G) &lt; S_f(X) \\Rightarrow R_i(X) + R_f(G) &lt; 2R_f(X) - 2 \\Rightarrow R_f(G) &lt; 2R_f(X) - R_i(X) - 2 $ 故摊还成本 &lt; 3Rf(X)−2Ri(X)−Ri(P)3R_f(X) - 2R_i(X) - R_i(P)3Rf​(X)−2Ri​(X)−Ri​(P) 又 $ R_i§ &gt; R_i(X) $ 故摊还成本 &lt; 3Rf(X)−3Ri(X)3R_f(X) - 3R_i(X)3Rf​(X)−3Ri​(X) 故一次调整，摊还成本为1+3(Rf(Root)−Ri(X))1 + 3(R_f(Root) - R_i(X))1+3(Rf​(Root)−Ri​(X)) 为O(logN) 故Splay trees连续的M次操作最坏情况是M次访问并调整，而每次调整的摊还时间复杂度是O(logN)，故M次操作的摊还时间复杂度为O(MlogN)","categories":[{"name":"-基础算法","slug":"基础算法","permalink":"https://woolseyyy.github.io/categories/基础算法/"}],"tags":[{"name":"-数据结构","slug":"数据结构","permalink":"https://woolseyyy.github.io/tags/数据结构/"}]},{"title":"Splay Trees 学习笔记","slug":"splay_tree","date":"2016-05-27T01:28:10.000Z","updated":"2019-10-12T05:28:47.900Z","comments":true,"path":"2016/05/27/splay_tree/","link":"","permalink":"https://woolseyyy.github.io/2016/05/27/splay_tree/","excerpt":"","text":"Splays Trees 也是一种二叉搜索树，用于提高连续搜索的效率。Splay Trees 通过将被访问到的节点放于根，提升访问速度。 它与AVL Trees 的效果有所区别。AVL树通过使树balanced降低树的高度至logN，从而使得单次搜索的复杂度为O(logN)。而Splay Trees则通过每次将被访问到的节点置于根，使得m次连续搜索的复杂度为O(mlogN)。 下面我们将介绍Splay Trees的实现及PTA中的相关题目。m次连续搜索复杂度为O(mlogN)我们在摊还分析博文中进行证明。 实现 根据不同的情况，Splay Trees采取不同的调整方法，直到被访问的节点置于根节点。 我们记被访问的节点为X，其父节点为P，其祖父节点为G。 首先我们将情况分为P是根节点和不是根节点。 P是根节点 交换P与X。结束调整。 P不是根节点 在该情况下，分为zig-zig情况和zig-zag情况。根据不同情况采取不同的旋转方法，旋转结束后，继续调整，直到被访问的节点处于根节点。 Zig-Zig X, P, G处于同一方向时，只需旋转一次，将X, P, G颠倒即可。 Zig-Zag X, P, G处于不同方向时，需要旋转两次，先旋转P, X，再旋转X, G 删除 在删除一个节点时，按如下步骤操作： 找到并删除该节点 访问该节点子树中最大的节点（此时该最大节点会处于该子树的根，且没有right child） 使删除节点的右子树成为 左子树最大节点 的right child 题目 For the result of accessing the keys 3, 9, 1, 5 in order in the splay tree in the following figure, which one of the following statements is FALSE? (1分) A. 5 is the root B. 1 and 9 are siblings C. 6 and 10 are siblings D. 3 is the parent of 4 答案是D","categories":[{"name":"-基础算法","slug":"基础算法","permalink":"https://woolseyyy.github.io/categories/基础算法/"}],"tags":[{"name":"-数据结构","slug":"数据结构","permalink":"https://woolseyyy.github.io/tags/数据结构/"}]},{"title":"AVL Trees 学习笔记","slug":"avl_tree","date":"2016-05-26T04:19:05.000Z","updated":"2019-10-12T04:51:42.195Z","comments":true,"path":"2016/05/26/avl_tree/","link":"","permalink":"https://woolseyyy.github.io/2016/05/26/avl_tree/","excerpt":"","text":"AVL Trees 是一种特殊的二叉搜索树，它的作用是通过自我调整，让整棵树保持平衡，从而降低整棵树的高度，以提高查找效率。 本文将首先介绍AVL Trees，然后介绍它的实现方法，性能评估，最后分析题目。 Introduction 特点 通过自我调整使树趋于平衡，降低树的高度，提高搜索效率 本质 二叉搜索树 变化 相比于二叉搜索树，有两个变化，一是每个节点增加了BF属性用于存储左子树和右子树的高度差，二是每次增加或删除节点后都会进行调整，使之balance 实现 结构 增加了BF属性的二叉搜索树 1234567typedef struct node* tree;struct node&#123; element key; tree left; tree right; int BF;&#125; BF = height of left tree - height of right tree 通过判断每个节点的BF值判断树是否height balanced. 若失去平衡，则开始调整。 Height Balanced An empty binary tree is height balanced. If T is a nonempty binary tree with TL and TR as its left and right subtrees, then T is height balanced iff (1) TL and TR are height balanced, and (2) | hL - hR | &lt; 1 where hL and hR are the heights of TL and TR , respectively. 调整触发条件 更新BF值 从增加或删除节点的位置开始向上遍历，访问BF值 若有BF&lt; -1 || BF &gt; 1 调整该节点及其子树 若一直到根节点BF都正常则无需调整 调整完成，更新BF值 调整 共有 RR, LL, RL, LR 四种情况 RR 需要注意的是，矩形（如BL，BR， AL）表示的不是一个节点，而是表示一棵子树，A表示的不一定是root，而是一个Trouble Maker节点。 LL LL情况与RR相似，它们是对称的。它们的共同点是，都是在**从 *Trouble Maker节点 *到 *其子节点 * 到 子节点的子树 **这条路径上，旋转一次。 LR LR和RL的情况就要稍微复杂，需要进行两次旋转。 这次旋转中事实上包括了两次旋转，首先是B, C, C的子树路径上进行一次左旋转： 然后是A, C, B路径上的第二次旋转: RL RL的情况与LR情况相似 性能评估 每次操作需要遍历从最底端到root的各个节点，时间复杂度为O(h)，调整操作时间复杂度为O(1)。故每次操作时间复杂度为O(h)。 又 h = O(lnN) 故操作时间复杂度为O(lnN) 证明 h = O(lnN) 记一个高度为h的树，节点数为nh 一棵高度为h，节点数最少的树是这样的形式： 由此我们可以得出nh = nh-1 + nh-2 + 1 令Fi = nh + 1 有Fi = Fi-1 + Fi-2 我们可以发现 Fi 符合斐波那契数列，且通过将h=1, h=2, h=3 代入，我们可以得出i = h+2 即 nh+2 - 1 符合斐波那契数列 根据斐波那契数列的理论 $ F_i = \\frac{1}{\\sqrt 5} (\\frac{1+{\\sqrt 5}}{2})^i $ 我们可以得到 $ n_h = \\frac{1}{\\sqrt 5} (\\frac{1+{\\sqrt 5}}{2})^{h+2} - 1 $ 故 h=O(lnN) 分析题目 Insert 2, 1, 4, 5, 9, 3, 6, 7 into an initially empty AVL tree. Which one of the following statements is FALSE? (1分) A. 4 is the root B. 2 and 6 are siblings C. 3 and 7 are siblings D. 9 is the parent of 7 让我们来模拟插入的过程 故答案为C If the depth of an AVL tree is 6 (the depth of an empty tree is defined to be -1), then the minimum possible number of nodes in this tree is: (1分) A. 13 B. 17 C. 20 D. 33 在证明h=O(lnN)的过程部分我们有 n最少时，nh = nh-1 + nh-2 + 1 又 depth = height - 1 故ndepth=6 = n7 = 33 答案为 D","categories":[{"name":"-基础算法","slug":"基础算法","permalink":"https://woolseyyy.github.io/categories/基础算法/"}],"tags":[{"name":"-数据结构","slug":"数据结构","permalink":"https://woolseyyy.github.io/tags/数据结构/"}]}]}